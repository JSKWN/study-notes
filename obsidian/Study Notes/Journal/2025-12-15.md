우선은 지난주에 뭘 하려고 했는지 기억을 되살려보자.
- 텐서플로우 기능 정리했던것 같음. 
	- 데이터 로딩 및 사용자 정의 레이어
- 주기길이 개발 관련 파이썬 모듈들을 좀 다듬는 과정에서, data_loader.py에서 데이터를 로딩하는 방식 세가지를 정리했었음.
	- tf.data.Dataset 객체 → from_tensor_slices()와 from_generator()
	- tf.data.TFRecordDataset
- 사용자 정의 레이어도 정리를 좀 했었는데 여전히 이해가 좀 안가긴해.

사용자 정의 레이어와 모델, 두 가지를 주로 사용.
- 그렇지만 클래스 상속 후 구현 해야 할 메서드는 동일하고 항상 정해져 있는 듯 함. 
	- init()
		- 클래스 정의 후, init() 메서드에서 super.init() 호출해야함.
		- 레이어 클래스 전체에 적용될 필터 수, 속성 값 등을 설정.
		- 내부에서 사용할 하위 레이어 정의
	
	- build()
		- 도대체 build()를 왜 사용하는지, 구현해야 하는지 이해를 못하겠다. 가중치를 저장하는 역할이라고 하는데
			- self.w = self.add_weight(shape=(input_shape[-1], 32)) → 이 때, self.w라는 변수명은 튜토리얼의 관습적인 표현이고, Tensorflow 프레임워크가 강제하는 예약어가 아님.  
			- **중요한건 add_weight()임 → 업데이트 대상 변수로 설정한다는 것**
			- 학습할 가중치가 없는 레이어면, build()를 구현하지 않아도 된다고 하지만, 가중치가 있다면 build()가 필요.
			- 레이어를 처음 구성하고, build가 되기 전에는 가중치 행렬 자체가 메모리에 없는 상태임(0으로 채워져 있지도 않은 듯)
		- Model 클래스를 상속 받아 만드는 사용자 정의 모델의 경우는, 굳이 build() 메서드를 구현할 필요가 없음 → Layer들이 모여 만드는게 Model이고, 이미 레이어들에서 해당 메서드들이 구현되어, 가중치를 부여했기 때문에 굳이 구현할 필요는 없음
		- 가중치 행렬을 생성하려면 두가지 차원 정보가 필요함 → 입력 및 출력 차원
		- 레이어를 인스턴스화 하는, `__init__`호출 시점에서는 이 레이어에 들어올 입력 형태를 알 수 없으므로, 가중치(W) 행렬을 위한 메모리를 할당할 수 없음. (따라서 `__init__`단계에서는 가중치 텐서(tf.variable)를 생성할 수 없음)
		- Keras는 지연 실행(Lazy Execution) 패턴을 사용하며, 가중치 생성을 데이터가 처음 주입되는 시점까지 미루는 것을 의미.
			- build() 메서드는 프레임워크에 의해, 다음 두가지 시점에 자동으로 호출됨.
				- 모델에 최초로 데이터가 통과할 때 (call 메서드 실행 직전)
				- model.build(input_shape) 메서드를 명시적으로 호출했을 때
		- | 메서드          | 시점      | 역할                                | 가중치 상태                      |
| ------------ | ------- | --------------------------------- | --------------------------- |
| **__init__** | 객체 생성 시 | 하이퍼파라미터 저장 (예: units, activation) | 생성 불가 (입력 차원 미상)            |
| **build**    | 최초 실행 시 | **가중치 메모리 할당** (self.add_weight)  | tf.Variable 객체 생성 및 초기화값 할당 |
| **call**     | 매 실행 시  | 전파 연산 (Forward Pass) 수행           | 생성된 가중치 사용                  |

		- 메모리 관점에서는 
		- 가중치, 가중치 `self.w`는 `tf.Variable`로 생성된 객체이며 메모리에 존재하는 텐서에 대한 핸들 또는 참조.


### 언제 build() 및 add_weight()를 구현해야하는지

| 패턴                        | 상황                                                                      | build() 구현 여부      | add_weight() 사용 여부 | 이유                                                   |
| ------------------------- | ----------------------------------------------------------------------- | ------------------ | ------------------ | ---------------------------------------------------- |
| **1. 조합 (Composition)**   | 기존 레이어(Dense, Conv 등)를 조립해서 사용할 때                                       | **불필요 (생략 가능)**    | **X (안 함)**        | 하위 레이어들이 각자 알아서 자신의 build()를 수행하므로.                  |
| **2. 커스텀 연산 (Low-level)** | 직접 수식(<br><br>```<br>X⋅WX⋅W<br>```<br><br> 등)을 짜거나, 특수한 형태의 파라미터가 필요할 때 | **필수 (Mandatory)** | **O (필수)**         | 입력 차원(input_shape)을 알아야 행렬 크기를 결정하고 메모리를 할당할 수 있으므로. |
| **3. 하이브리드 (Hybrid)**     | 위 두 가지를 섞어서 사용할 때 (예: Attention 코드)                                     | **필수**             | **O (부분적 사용)**     | 커스텀 파라미터(예: Bias Table)를 위해서라도 build가 필요함.           |

---


이 다음에 할 건, .py들로 나눈 모듈들 내용을 완성. 지금 models.py를 했었으니 사용자 정의 레이어 내용을 공식 문서 참고해서 정리한 다음, 해당 모듈 완성. 이후, mlflow 적용 (이 과정에서 mlflow 내용도 정리해야 할 수 있음)